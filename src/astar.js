/*
A busca A*(A-estrela) é um algoritmo para Busca de Caminho.
Ele busca o caminho em um grafo de um vértice inicial até um vértice final.
Ele é a combinação de aproximações heurísticas como do algoritmo Breadth First Search (Busca em Largura) e da formalidade do Algoritmo de Dijkstra.
O algoritmo foi descrito pela primeira vez em 1968 por Peter Hart, Nils Nilsson, e Bertram Raphael.
Na publicação deles, ele foi chamado de algoritmo A; usando este algoritmo com uma heurística apropriada atinge-se um comportamento ótimo, e passou a ser conhecido por A*.
Sua aplicação vai desde aplicativos para encontrar rotas de deslocamento entre localidades a resolução de problemas,
como a resolução de um quebra-cabeças. Ele é muito usado em jogos.
*/

class AStar {
  constructor(graph, start, goal) {
    this.graph = graph;  // Grafo com os vértices e arestas
    this.start = start;  // Nó inicial
    this.goal = goal;    // Nó objetivo
    this.openList = [];   // Lista de nós a serem explorados
    this.closedList = new Set();  // Lista de nós já explorados
    this.gScore = {};  // Geração do custo acumulado até o nó
    this.fScore = {};  // Estimativa total (g(n) + h(n))
    this.cameFrom = {}; // Para reconstruir o caminho

    // Inicializando as listas
    this.openList.push(start);
    this.gScore[start] = 0;  // Custo de ir de start até start é 0
    this.fScore[start] = this.heuristic(start);  // A heurística inicial
  }

  // Função de Heurística: Usando a distância restante como estimativa
  heuristic(node) {
    // Neste exemplo, vamos utilizar a distância como heurística
    // A distância será a distância entre o nó atual e o objetivo.
    if (!this.graph[node] || !this.graph[this.goal]) return Infinity;
    return this.graph[node][this.goal]?.distance || Infinity;
  }

  // Função para reconstruir o caminho
  reconstructPath(current) {
    let path = [current];
    while (this.cameFrom[current]) {
      current = this.cameFrom[current];
      path.push(current);
    }
    return path.reverse();
  }

  // Função A* que retorna o caminho mais curto
  findPath() {
    while (this.openList.length > 0) {
      // Escolher o nó com o menor fScore
      let current = this.openList.reduce((a, b) => {
        return this.fScore[a] < this.fScore[b] ? a : b;
      });

      // Se chegamos no objetivo, reconstruímos o caminho
      if (current === this.goal) {
        return this.reconstructPath(current);
      }

      // Mover o nó atual para a closedList
      this.openList = this.openList.filter(node => node !== current);
      this.closedList.add(current);

      // Explorar os vizinhos
      for (let neighbor in this.graph[current]) {
        if (this.closedList.has(neighbor)) continue;

        // Cálculo do custo de g(n) usando o peso da aresta
        let tentativeGScore = this.gScore[current] + this.graph[current][neighbor].weight;

        // Se o vizinho não estiver na openList ou encontrarmos um caminho melhor
        if (!this.openList.includes(neighbor) || tentativeGScore < this.gScore[neighbor]) {
          // Atualizar os valores
          this.cameFrom[neighbor] = current;
          this.gScore[neighbor] = tentativeGScore;
          this.fScore[neighbor] = tentativeGScore + this.heuristic(neighbor);

          // Adicionar o vizinho à openList se ainda não estiver lá
          if (!this.openList.includes(neighbor)) {
            this.openList.push(neighbor);
          }
        }
      }
    }

    // Se não encontramos um caminho, retornamos null
    return null;
  }
}
module.exports = AStar;
/*
The @Response 2 generated the test code perfectly, while @Response 1 generated test code with errors. In addition, @Response 2 has a better explanation of the tests.
In the IF requeriment, @Response 1 was not faithfull to the prompt.
Finally, in the Truthfulness requirement, the code generated by @Response 1 contains errors,
whereas that generated by @Response 2 is perfect.
*/